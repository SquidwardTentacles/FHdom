<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=2, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <script src="./jquery.min.js"></script>
  </head>
  <body>
    <canvas class="canvas" id="draw" width="200" height="200"></canvas>
    <img
      src="./Snipaste_2019-12-16_14-47-06.png"
      id="imageData"
      alt=""
      srcset=""
    />
  </body>
  <style></style>
  <script>
    // // 定义一个人 类 appply(this指向，数据) 用于更改函数的this指向 提取数组中的值 与es6扩展运算符...作用一样
    // function Person(name, age) {
    //   this.name = name;
    //   this.age = age;
    // }
    // // 定义一个学生类
    // function Student(name, age, grade) {
    //   console.log(this, arguments);
    //   Person.apply(this, arguments);
    //   this.grade = grade;
    // }
    // // 创建一个学生类
    // var student = new Student("zhangsan", 18, "初三");
    // console.log(student);

    // var arr1 = [0, 1, 2, 3];
    // var arr2 = [4, 5, 6];
    // Array.prototype.push.apply(arr1, arr2);
    // console.log(arr1);

    // 扩展运算符的使用
    // 1，赋值数组（数组是复合数据类型 直接复制 只是复制了指向底层数据的指针 而不是克隆一个全新的数组）
    // const a1 = [1, 2];
    // const a2 = a1;
    // console.log(a2);
    // // 会改变原数组
    // a2[0] = 0;
    // console.log(a1, a2);
    // 解决方法
    // es5
    // const a2 = a1.concat();
    // console.log(a2);
    // a2[0] = 3;
    // console.log(a1, a2);
    // es6
    // const a2 = [...a1];
    // a2[0] = 0;
    // console.log(a1, a2);

    // Array.from() 将对象转化为数组
    // let obj = {
    //   "0": "a",
    //   "1": "b",
    //   "2": "c",
    //   length: 3
    // };
    // let arr = Array.from(obj);
    // console.log(Array.from(obj));

    // canvas画图
    // $(document).ready(function() {
    //   let drawing = document.getElementById("draw");
    //   if (drawing.getContext) {
    //     let content = drawing.getContext("2d");
    //     // // 获取图像的数据url
    //     // let imgURL = drawing.toDataURL('image/png');
    //     // // 显示图像
    //     // let image = document.createElement('img');
    //     // image.src = imgURL;
    //     // document.body.appendChild(image);

    //     // content.strokeStyle = 'red';
    //     // content.fillStyle = '#0000ff';

    //     // 绘制红色矩形
    //     // content.fillStyle = '#ff0000';
    //     // content.fillRect(10, 10, 50, 50);
    //     // // 绘制半透明矩形
    //     // content.fillStyle = 'rgba(0,0,255,0.5)';
    //     // // fillRect() 接收四个参数 矩形的XY坐标矩形的宽高
    //     // content.fillRect(30, 30, 50, 50);
    //     // strokeRect()对矩形使用指定的颜色描边 颜色使用strokeStyle指定
    //     // content.strokeStyle = '#ff0000';
    //     // content.strokeRect(10, 10, 50, 50);
    //     // // 绘制半透明的蓝色描边矩形
    //     // content.strokeStyle = 'regba(0,0,255,0.5)';
    //     // content.strokeRect(30, 30, 50, 50);
    //     // clearRect() 用于清除画布上的矩形区域
    //     // 绘制红色矩形
    //     // content.fillStyle = '#f00';
    //     // content.fillRect(10, 10, 50, 50);
    //     // // 绘制半透明矩形
    //     // content.fillStyle = 'rgba(0,0,255,0.5)';
    //     // content.fillRect(30, 30, 50, 50);
    //     // // 在重叠的地方额清除一个小矩形
    //     // content.clearRect(40, 40, 10, 10);
    //     // 绘制一个时钟矩形
    //     // 开始路径
    //     // content.beginPath();
    //     // // 绘制外圆 arc(x,y,radius,startAngle,endAngle,counterclockwise) 以（x,y）为圆心 绘制一条弧线 半径为radius 起始和结束角度(用弧度表示)分别为startAngle和endAngle 最后一个参数表示是否逆时针计算
    //     // // 绘制外圆
    //     // content.arc(100, 100, 99, 0, Math.PI, false);
    //     // // 绘制内圆
    //     // content.moveTo(190, 100);
    //     // content.arc(100, 100, 90, 0, Math.PI, false);
    //     // // 绘制分针 lineTo(x,y) 从上一点绘制直线 到(x,y)为止
    //     // // content.moveTo(100, 100);
    //     // // content.lineTo(100, 15);
    //     // // // 绘制时针
    //     // // content.moveTo(100, 100);
    //     // // content.lineTo(35, 100);
    //     // // 描边路径
    //     // content.stroke();0

    //     // 开始路径
    //     // content.beginPath();
    //     // // 绘制外圆
    //     // content.arc(100, 100, 99, 0, 2 * Math.PI, false);
    //     // // 绘制内圆
    //     // // 移动原点
    //     // content.moveTo(194, 100);
    //     // // isPointInpath(x,y) 用于在路径关闭之前确定画布上的某一点是否位于路径上
    //     // if (content.isPointInPath(194, 100)) {
    //     //   console.log('has');
    //     // }
    //     // content.arc(100, 100, 94, 0, 2 * Math.PI, false);
    //     // // 绘制分针
    //     // content.moveTo(100, 100);
    //     // content.lineTo(100, 30);
    //     // // 绘制时针
    //     // content.moveTo(100, 100);
    //     // content.lineTo(50, 100);
    //     // // 描边路径
    //     // content.stroke();
    //     /*
    //     绘制文本 主要有两个方法 fillText() 和 strokeText() 这两个方法都接收四个参数 要绘制的文本字符串 (x,y)坐标 和可选的最大像素宽度 这两个方法都以下面3个属性为基础
    //     font 表示文本样式、大小及字体 用css中指定字体的格式来指定
    //     textAlign 表示文本的对齐方式 建议使用 'start'、'end'代替 'left'、'right'因为前两者的意思更加稳妥 能同时适合从左到右和从右到左显示（阅读）的语言
    //     textBaseline:表示文本的基线
    //     */
    //     // 在表盘上绘制12
    //     // content.font = 'bold 14px Arial';
    //     // content.textAlign = 'center';
    //     // content.fillText('12', 100, 20);
    //     // content.fillText('12', 100, 20);

    //     // content.fillText('9', 20, 100);
    //     // content.fillText('6', 100, 180);
    //     // content.fillText('3', 180, 100);
    //     // console.log(content.measureText('3'));
    //     // let imgURL = drawing.toDataURL('image/png');
    //     // let img = document.createElement('img');
    //     // img.src = imgURL;
    //     // document.body.appendChild(img);
    //     /*
    //       translate(x,y) 将坐标原点移动到(x,y) 执行变换之后坐标(0,0)会变成之前由(x,y)表示的点
    //       使用translate绘制如上图形
    //     */
    //     // // 开始绘图
    //     // content.beginPath();
    //     // // 外圆
    //     // content.arc(100, 100, 99, 0, 2 * Math.PI, false);
    //     // // 内圆
    //     // // 移动光标
    //     // content.moveTo(194, 100);
    //     // content.arc(100, 100, 94, 0, 2 * Math.PI, false);
    //     // // 绘制时针 分针 首先变换原点到表盘的中心为原点
    //     // content.translate(100, 100);
    //     // /*
    //     //   调用save()方法后 当前所有的设置都会进入一个栈结构 得以妥善保管 等要回到之前保存的设置 可以调用restore() 方法 在保存设置的栈结构中向前返回一级 恢复之前的状态 连续调用即可一级级返回
    //     //   注意 save() 方法保存的是对绘图上下文的设置和变换 不会保存绘图上下文的内容
    //     // */
    //     // content.save();

    //     // content.rotate(1);

    //     // content.moveTo(0, 0);
    //     // content.lineTo(0, -70);

    //     // content.restore();
    //     // content.moveTo(0, 0);
    //     // content.lineTo(-50, 0);
    //     // // 描边路径

    //     // content.font = 'bold 14px Arial';
    //     // content.textAlign = 'center';
    //     // content.fillText('12', 0, -80);
    //     // content.fillText('3', 80, 0);
    //     // content.fillText('6', 0, 80);
    //     // content.fillText('9', -80, 0);
    //     // content.stroke();

    //     // let imgUrl = drawing.toDataURL('image/png');
    //     // let img = document.createElement('img');
    //     // img.src = imgUrl;
    //     // document.body.appendChild(img);

    //     /*
    //       绘制图像如果想把图片绘制到画布上 可以使用drawImage()方法 根据期望的最终结果不同 调用这个方法时 可以使用三种不同的参数组合 最简单的调用方法是传入一个html img元素 以及绘制图像的起点(x,y)坐标 如果希望改变图形大小 可以再多传入两个参数分别表示目标的宽高  还可以选择将图形的某个部分绘制到上下文中 这种调用方式总共需要9个参数 源图像的(x,y)坐标 原图形的宽高 目标图像的(x,y)目标图像的宽高
    //     */
    //     // 生成一个图片
    //     // let img = document.createElement('img');
    //     // img.src = './Snipaste_2019-10-24_15-36-57.png';
    //     // // 等待图片加载完成后再进行绘制图片
    //     // img.onload = () => {
    //     //   content.drawImage(img, 0, 10, 30, 30, 10, 10, 30, 30);
    //     //   content.stroke();
    //     // };
    //     // 渐变
    //     /*
    //       渐变由canvasGradient实例表示 创建一个新的线性渐变可以调用createLinearGradient()方法 这个方法接收四个参数 起点的(x,y)坐标 终点的(x,y)坐标 调用这个方法后 它会创建一个指定大小的渐变 并返回CanvasGraddient对象的实例
    //       创建了渐变对象之后 下一步就是使用addColorStop()方法来指定色标 这个方法接收两个参数 色标的位置和css的颜色值 色标位置是一个0（开始的位置）到1（结束的位置）之间的颜色
    //     */
    //     // let gradient = content.createLinearGradient(30,30,70,70)
    //     // gradient.addColorStop(0,'white')
    //     // gradient.addColorStop(1,'black')
    //     // /*
    //     //   gradient对象表示的是上点(30,30)到(70,70)的渐变 起点色标是白色 终点色标是黑色 然后就可以吧fillStyle或strokeStyle设置为这个对象 从而使用渐变来绘制形状或描边
    //     // */
    //     // // 绘制红色矩形
    //     // content.fillStyle = '#ff0000'
    //     // content.fillRect(10,10,50,50)
    //     // // 绘制渐变矩形
    //     // content.fillStyle = gradient
    //     // content.fillRect(30,30,50,50)

    //     $.ajax = {
    //       url: "http://192.168.1.4:3000/getIgmaData",
    //       type: "get",
    //       success: function(res) {
    //         console.log(res);
    //       },
    //       err: function(err) {
    //         console.log(err);
    //       }
    //     };

    //     // let img = document.images[0];
    //     // console.log(img);
    //     // img.onload = () => {
    //     //   content.drawImage(img, 0, 0);
    //     //   let imageData;
    //     //   imageData = content.getImageData(0, 0, img.width, img.height);
    //     //   console.log(imageData);
    //     // };
    //   }
    // });

    // symbol
    // let s = Symbol("foo");
    // console.log(s.description);

    // let obj = {};
    // let mySymbol = Symbol();
    // obj.a = Symbol("foo");
    // console.log(obj.a);

    let obj = {
      name: "对象",
      type: "1",
    };
    console.log(obj.type);
    delete obj.type;
    console.log(obj.type);

    // function CreateDog(name, color) {
    //   this.name = name;
    //   this.color = color;
    // }
    // CreateDog.prototype.age = 10;

    // let tom = new CreateDog("tom", "blue");
    // // 当实例属性与原型中的属性重名时 修改其属性值 会覆盖原型中的属性 如果删除实例属性 将会显示原型中的属性值
    // let toy = new CreateDog("toy", "13");
    // tom.age = 20;
    // // delete tom.age;
    // // console.log(tom.age);
    // // console.log(toy.age);

    // // 实例对象中的 引用属性 在其中的一个实例中被更改 则所有的实例获取该属性都将获得新的值 如果修改普通属性 则只会更改当前的实例的值
    // function CreateArr() {}
    // CreateArr.prototype.arr = ["a", "d", "c"];
    // CreateArr.prototype.age = 30;
    // var arr1 = new CreateArr();
    // var arr2 = new CreateArr();
    // // 给普通属性赋值 只会修改当前属性
    // arr1.age = 40;
    // // 给引用属性赋值 则会修改所有
    // // arr1.arr.push("f");
    // console.log("arr1", arr1.age, "arr2", arr2.age);
    // console.log(arr2.arr);
    // // 初始化一个实例之后 再给函数的原型对象赋值 已创建的实例与新的原型对象不会有任何联系 也就是说已创建的实例不能访问新的原型对象
    // var group = new CreateArr();
    // CreateArr.prototype = {
    //   arr2: ["a", "d", "c", "d"],
    // };
    // console.log(group.arr2);

    // 结合使用构造函数和原型模式 单独使用原型模式会有弊端 但和其它模式组合起来 这些问题就迎刃而解了 典型的使用就是组合使用构造函数与原型模式 它是当前ECMAScript中认同度最高 使用最广泛地一种创建自定义类型的方法
    function MyToy(owenr) {
      this.owenr = owenr;
      this.group = ["a", "b", "c"];
    }
    MyToy.prototype.sayOwer = function () {
      console.log(this.owenr);
    };
    var lileis = new MyToy("lilei");
    var hanMeimeis = new MyToy("han Meimei");
    lileis.group.push("po");
    console.log("lilei", lileis.group);
    console.log("han", hanMeimeis.group);
  </script>
</html>
